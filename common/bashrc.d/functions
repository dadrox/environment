# A bunch of bash functions that I find useful for various purposes
#
# DEPENDS ON ack-grep... you're welcome.  At least on Ubuntu/Mint it is ack-grep.  On OSX homebrew it is just ack

cmds () {
    cat $HOME/.bashrc.d/bash_functions | grep "()" | grep -v "^_" | egrep -v "^[A-Z_]*=" | grep -v "cmds" | grep -v "^\s*#" | sed "s/\s\?()//" | sed 's/ { \# /\t/' | awk '{ printf "%-20s %s\n", $1, substr($0,index($0,$2)) }'
}

hr() { # echoes a horizontal rule
	printf "${Yellow}%$(tput cols)s${Normal}\n"|tr ' ' '='
}

cb() { # cd up to a certain directory name
    pushd `pwd | sed -r "s/($1).*/\\1/"`
}

_find_file_w_extension() {
    find . -type f -name $1
}

scala_files() { # find all scala files from the current directory
    _find_file_w_extension "*.scala"
}

groovy_files() { # find all groovy files from the current directory
    _find_file_w_extension "*.groovy"
}

java_files() { # find all java files from the current directory
    _find_file_w_extension "*.java"
}

_grepit() {
	xargs ack-grep --color-filename=yellow --color-match="green" "$@"
}

_find_whatev() {
	$1 | _grepit "$2"
}

_find_whatev_i() {
	$1 | _grepit -i "$2"
}

fs() { # finds a given string in scala files.
	hr
	_find_whatev scala_files "$@"
	hr
}

fsi() { # finds a given string in scala files (case-insensitive)
	hr
	_find_whatev_i scala_files "$@"
	hr
}

fsc() { # finds a scala class, object, or trait (case-insensitive)
    scala_files | xargs ack-grep -il --color-match=yellow  --match "(class|object|trait) [a-zA-Z]*$1"
}

fsco() { # finds a scala class, object, or trait (case-insensitive)
    scala_files | xargs ack-grep -il --color-match=yellow  --match "(class|object|trait)\s+$1[\s(\[]"
}

fa() { # finds a given string in any file
	find . -type f | _grepit "$@"
}

fai() { # finds a given string in any file (case-insensitive)
	find . -type f | _grepit -i "$@"
}

fsf() { # finds a scala file with the given string in its name (case-insensitive)
	scala_files | grep -i "$@"
}

fgr() { # finds a given string in groovy files
	_find_whatev groovy_files "$@"
}

fgri() { # finds a given string in groovy files (case-insensitive)
	_find_whatev_i groovy_files "$@"
}

fj() { # finds a given string in java files
	_find_whatev java_files "$@"
}

fji() { # finds a given string in java files (case-insensitive)
	_find_whatev_i java_files "$@"
}

fjar() { # find jar in ivy cache (case-insensitive)
	find ~/.ivy2/cache/ -iname "$@.jar"
}

fclass() { # find jar in ivy cache containing a class name with the given string (case-insensitive)
	find ~/.ivy2/cache/ -name "*.jar" -exec grep -il --color "$@" {} \;
}

ff() { # find a file name containing the given string
	find . -type f -iname "*$1*"
}

manifest() { # prints the manifest of the given jar
	unzip -p "$@" META-INF/MANIFEST.MF
}

backup-eclipse() { # zips all .classpath and .project files generated by eclipse
	zip -R eclipse.env.backup-`date +%Y%m%d`.zip .classpath .project
}

killgrep() { # kills all processes containing the string, killgrep <name> <signal>, E.g. killgrep java -1
	name="$1"
	signal="$2"
	echo "killing *$name* with $signal"
	ps aux | grep $name | awk '{print $2}' | xargs kill $signal
	echo "$name should be killed, check the list below"
	echo `ps -ef | grep $name`
}

list() { # lists the contents of several different types of archive files
     if [ -f $1 ] ; then
         case $1 in
             *.tar.bz2)   tar tvjf $1      ;;
             *.tar.gz)    tar tvzf $1      ;;
             *.bz2)       bunzip2 -ck $1   ;;
             *.rar)       unrar l $1       ;;
             *.gz)        gunzip -l $1     ;;
             *.tar)       tar tvf $1       ;;
             *.tbz2)      tar tvjf $1      ;;
             *.tgz)       tar tvzf $1      ;;
             *.zip)       unzip -l $1      ;;
             *.Z)         uncompress -l $1 ;;
             *.7z)        7z l $1          ;;
             *)           echo "'$1' cannot be listed" ;;
         esac
     else
         echo "'$1' is not a valid file"
     fi
}

extract() { # extracts several different types of archive files
     if [ -f $1 ] ; then
         case $1 in
             *.tar.bz2)   tar xvjf $1    ;;
             *.tar.gz)    tar xvzf $1    ;;
             *.bz2)       bunzip2 $1     ;;
             *.rar)       unrar x $1     ;;
             *.gz)        gunzip $1      ;;
             *.tar)       tar xvf $1     ;;
             *.tbz2)      tar xvjf $1    ;;
             *.tgz)       tar xvzf $1    ;;
             *.zip)       unzip $1       ;;
             *.Z)         uncompress $1  ;;
             *.7z)        7z x $1        ;;
             *)           echo "'$1' cannot be extracted via >extract<" ;;
         esac
     else
         echo "'$1' is not a valid file"
     fi
}

exclude-dir() { # recursivley excludes a directory name from dropbox
	find . -type d -name $1 -printf '%P\0 ' | xargs -0 dropbox exclude add '{}'
}

include-dir() { # recursivley removes exclusion of a directory name from dropbox
	find . -type d -name $1 -printf '%P\0 ' | xargs -0 dropbox exclude remove '{}'
}

resource() { # sources your .bashrc
	source $HOME/.bashrc
}

colors() { # prints sample of your color settings
T='gYw'   # The test text
echo -e "\n                 40m     41m     42m     43m\
     44m     45m     46m     47m";

for FGs in '    m' '   1m' '  30m' '1;30m' '  31m' '1;31m' '  32m' \
           '1;32m' '  33m' '1;33m' '  34m' '1;34m' '  35m' '1;35m' \
           '  36m' '1;36m' '  37m' '1;37m';
  do FG=${FGs// /}
  echo -en " $FGs \033[$FG  $T  "
  for BG in 40m 41m 42m 43m 44m 45m 46m 47m;
    do echo -en "$EINS \033[$FG\033[$BG  $T  \033[0m";
  done
  echo;
done
echo
}
